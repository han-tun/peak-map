{"version":3,"sources":["webpack:///./src/appState.js","webpack:///./src/lib/createSVGContext.js","webpack:///./src/lib/createHeightMapRenderer.js","webpack:///./src/config.js","webpack:///./src/elevation.js","webpack:///./src/main.js"],"names":["appState","angle","currentState","lineDensity","lineWidth","smoothSteps","mapOpacity","heightScale","oceanLevel","aboutVisible","error","zazzleLink","generatingPreview","settingsOpen","shouldDraw","renderProgress","width","window","innerWidth","height","innerHeight","backgroundColor","r","g","b","a","lineBackground","lineColor","createSVGContext","allPaths","currentPath","api","serialize","reverse","map","x","join","beginPath","segments","lastCommand","stroke","lineCount","lineTo","y","prefix","push","round","moveTo","strokeString","lineWidthString","isEmpty","setStroke","strokeStyle","setLineWidth","customLineWidth","createPath","Math","createHeightMapRenderer","regionInfo","canvas","renderHandle","render","cancel","cancelAnimationFrame","toSVG","message","parse_float_default","parseFloat","style","opacity","ctx","getContext","lineStroke","getColor","lineFill","resHeight","resWidth","rowCount","scale","_regionInfo$getAllHei","getAllHeightData","minHeight","maxHeight","rowWithHighestPoint","iteratorSettings","includeRowIndex","stepSize","start","floor","stop","step","createRegionIterator","heightRange","lastLine","lastRow","columnHeights","Float32Array","svg","row","drawSVGLine","isEven","i","getHeightAtPoint","fY","renderSVGRows","clearRect","fillStyle","fillRect","renderRows","now","performance","drawPolyLine","elapsed","requestAnimationFrame","points","length","getSmoothRange","wasVisible","lastRenderedColumnHeight","isVisible","min","smoothRange","max","closePath","fill","windowSize","result","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","leftOffset","to","count","sum","j","smoothHeight","color","useHex","hex","hexValue","toString","MAPBOX_TOKEN","apiURL","imageCache","getRegionElevation","progress","doneCallback","tileSize","tileZoom","transform","zoomPower","pow","coveringTiles","minzoom","maxzoom","tileBounds","reduce","bounds","tile","p","canonical","minX","minY","maxX","maxY","Infinity","document","createElement","Error","total","advanceProgress","heightsHandle","isCancelled","tilesToLoad","request","url","replace","z","getRequestForTile","cachedImage","get","promise_default","resolve","img","Image","onload","onerror","crossOrigin","src","set","then","image","drawImage","catch","finally","all","canvasWidth","data","getImageData","windowWidth","windowHeight","allHeights","done","timeQuota","lastY","collectHeights","startTime","index","getHeight","lngLat","pointLocation","xTile","l","lng2tile","lng","xOffset","yTile","PI","log","tan","cos","lat2tile","lat","yOffset","yC","xC","R","G","B","decodeHeight","visibleHeights","undefined","completed","MapboxGeocoder","require","bind","__webpack_require__","oe","heightMapRenderer","regionBuilder","hideHeights","querySelector","updateMap","heightMapCanvas","display","init","mapboxgl","accessToken","Map","trackResize","container","minZoom","center","zoom","hash","addControl","NavigationControl","showCompass","on","once","getBearing","dragRotate","disable","touchZoomRotate","disableRotation","redraw","exportToSVG"],"mappings":"sDAAA,IAAMA,GACJC,MAAO,EACPC,aAAc,QACdC,YAAa,GACbC,UAAW,EACXC,YAAa,EACbC,WAAY,IACZC,YAAa,GACbC,WAAY,EACZC,cAAc,EACdC,MAAO,KACPC,WAAY,KACZC,mBAAmB,EACnBC,cAAc,EACdC,YAAY,EACZC,eAAgB,KAChBC,MAAOC,OAAOC,WACdC,OAAQF,OAAOG,YAEfC,iBACEC,EAAG,IAAMC,EAAG,IAAMC,EAAG,IAAMC,EAAG,GAEhCC,gBAEEJ,EAAG,IAAMC,EAAG,IAAMC,EAAG,IAAMC,EAAG,GAEhCE,WACEL,EAAG,GAAIC,EAAG,GAAIC,EAAG,GAAIC,EAAG,IAIbzB,oJC3BA,SAAS4B,EAAiBZ,EAAOG,GAC9C,IAAIU,KACAC,SAEAC,GACFC,UAWF,WACE,sUAIchB,EAJd,IAIuBG,EAJvB,2BAMCU,EAASI,UAAUC,IAAI,SAAAC,GAAA,OAAKA,EAAEH,cAAaI,KAAK,MANjD,kBAXAC,UAsBF,WACEP,EAwBJ,WACE,IAAIQ,KACAC,EAAc,KACdC,SAAQpC,SACRqC,EAAY,EAEhB,OACEC,OA0BF,SAAgBP,EAAGQ,GACjBF,GAAa,EACb,IAAIG,EAAyB,MAAhBL,EAAsB,GAAK,IACxCD,EAASO,KAAT,GAAiBD,EAASE,EAAMX,GAAhC,IAAsCW,EAAMH,IAC5CJ,EAAc,KA7BdQ,OAmBF,SAAgBZ,EAAGQ,GACjB,IAAIC,EAAyB,MAAhBL,EAAsB,GAAK,IACxCD,EAASO,KAAT,GAAiBD,EAASE,EAAMX,GAAhC,IAAsCW,EAAMH,IAC5CJ,EAAc,KArBdP,UAYF,WACE,IAAIgB,EAAeR,aAAoBA,EAApB,KAAiC,GAChDS,EAAgC,IAAd7C,EAAA,iBAAmCA,EAAnC,IAAkD,GACxE,kBAAmBkC,EAASF,KAAK,KAAjC,iBAAsDY,EAAeC,EAArE,YAdAC,QAJK,WAKH,OAAqB,IAAdT,GAETU,UAPK,SAOKC,GACRZ,EAASY,GAEXC,aAVK,SAUQC,GACXlD,EAAYkD,IAzCAC,IAtBdb,OAyBF,SAAgBP,EAAGQ,GACjBb,EAAYY,OAAOP,EAAGQ,IAzBtBI,OA4BF,SAAgBZ,EAAGQ,GACjBb,EAAYiB,OAAOZ,EAAGQ,IA5BtBH,OA+BF,WACMV,IAAgBA,EAAYoB,YAC1BnB,EAAIqB,aACNtB,EAAYqB,UAAUpB,EAAIqB,aAExBrB,EAAI3B,WACN0B,EAAYuB,aAAatB,EAAI3B,WAE/ByB,EAASgB,KAAKf,KAtChB1B,UAAW,EACXgD,YAAa,WAGf,OAAOrB,EAgFT,SAASe,EAAMX,GACb,OAAOqB,KAAKV,MAAU,IAAJX,GAAS,IC1Fd,SAASsB,EAAwBzD,EAAU0D,EAAYC,GACpE,IAAIC,SAIJ,OAFAC,KAMEC,OA0NF,WACEC,qBAAqBH,GACrB5D,EAASe,eAAiB,MA3N1B8C,UAGF,SAASA,EAAOG,GAEVhE,EAASe,iBACXf,EAASe,eAAekD,QAAU,gBAGpC,IAAMzD,EAAa0D,IAAkBlE,EAASQ,YAE1CH,EAAc8D,WAAWnE,EAASK,aAEtCsD,EAAOS,MAAMC,QAAUrE,EAASM,WAAW,IAE3C,IAAIgE,EAAMX,EAAOY,WAAW,MACxBC,EAAaC,EAASzE,EAAS2B,WAC/B+C,EAAWD,EAASzE,EAAS0B,gBAC7BtB,EAAY8D,IAAkBlE,EAASI,WAEvCuE,EAAY1D,OAAOG,YACnBwD,EAAW3D,OAAOC,WAClB2D,EAAWrB,KAAKV,MAAM6B,EAAY3E,EAASG,YAAY,KACvD2E,EAAQ9E,EAASO,YApBAwE,EAwB+BrB,EAAWsB,mBAAxDC,EAxBcF,EAwBdE,UAAWC,EAxBGH,EAwBHG,UAAWC,EAxBRJ,EAwBQI,oBACvBC,EAyOR,SAA8BP,EAAUF,EAAWU,GACjD,IAAIC,EAAW9B,KAAKV,MAAM6B,EAAYE,GAClCU,EAAQF,EAAkB7B,KAAKgC,MAAMH,EAAgBC,GAAYA,EACjEG,EAAOF,EAAQD,EAAW9B,KAAKgC,OAAOb,EAAYY,GAASD,GAE/D,OACEC,QACAE,OACAC,KAAMJ,GAjPiBK,CAAqBd,EAAUF,EAAWQ,GAI/DS,EAAcV,EAAYD,EAE1BY,KACAC,EAAUV,EAAiBG,MAI3BQ,SAEJ,GAAI/B,EAAO,CAETQ,EAAaC,EAASzE,EAAS2B,WAA0B,GACzDoE,EAAgB,IAAIC,aAAa/E,OAAOC,YACxC4E,EAAUV,EAAiBK,KAI3B,IAAK,IAAItD,EAAI,EAAGA,EAAIlB,OAAOC,aAAciB,EACvC4D,EAAc5D,GAAKlB,OAAOG,YAE5B,OAQF,WAIE,IAHA,IAAI6E,EAAMrE,EAAiBX,OAAOC,WAAYD,OAAOG,aACjD8E,EAAM,EACNlF,EAAQC,OAAOC,WACVyB,EAAImD,EAASnD,EAAI,EAAGA,GAAKyC,EAAiBM,KAAM,CACvDS,EAAYN,EAAUI,GACtBJ,KACA,IAAIO,EAAUF,EAAM,GAAO,EAC3BA,GAAO,EAEP,IAAK,IAAIG,EAAI,EAAGA,EAAIrF,EAAOqF,GAAK,EAAG,CACjC,IAAIlE,EAAIiE,EAASC,EAAIrF,EAAQ,EAAIqF,EAC7BlF,EAASuC,EAAW4C,iBAAiBnE,EAAGQ,GACxC4D,EAAK5D,EAAIa,KAAKgC,MAAMV,GAAS3D,EAAS8D,GAAaW,GACnDzE,GAAUX,GACZ2F,EAAYN,EAAUI,GACtBJ,MAEAA,EAAShD,KAAKV,EAAGoE,GAIrBT,EAAUnD,EAAIyC,EAAiBM,KAMjC,GAHAS,EAAYN,EAAUI,GAEtBjG,EAASe,eAAiB,KACtBkF,EAAIjE,UAEN,OAAOiE,EAAIjE,YAtCNwE,GAGP,OA2JAlC,EAAIjC,YACJiC,EAAImC,UAAU,EAAG,EAAG7B,EAAUD,GAC9BL,EAAIoC,UAAYjC,EAASzE,EAASqB,iBAClCiD,EAAIqC,SAAS,EAAG,EAAG/B,EAAUD,GAnH/B,SAASiC,IACP,IAAIC,EAAMC,YAAYD,MAEtB,IAAK,IAAIlE,EAAImD,EAASnD,GAAKyC,EAAiBK,KAAM9C,GAAKyC,EAAiBM,KAAM,CAC5EqB,EAAalB,GACbA,KAEA,IAAK,IAAI1D,EAAI,EAAGA,EAAIlB,OAAOC,aAAciB,EAAG,CAC1C,IAAIhB,EAASuC,EAAW4C,iBAAiBnE,EAAGQ,GACxC4D,EAAK5D,EAAIa,KAAKgC,MAAMV,GAAS3D,EAAS8D,GAAaW,GAEnDzE,GAAUX,GACZuG,EAAalB,GACbA,MAEAA,EAAShD,KAAKV,EAAGoE,GAIrBT,EAAUnD,EAAIyC,EAAiBM,KAC/B,IAAIsB,EAAUF,YAAYD,MAAQA,EAClC,GAAIG,EAAU,IAEZ,YADApD,EAAeqD,sBAAsBL,IAKzCG,EAAalB,GAEb7F,EAASe,eAAiB,KAxEnB6F,GAiFT,SAAST,EAAYe,EAAQjB,GAC3B,KAAIiB,EAAOC,OAAS,GAApB,CAGAD,EADkBE,EAAeF,EAAQ7G,GACpB6G,OAErBjB,EAAI5D,YACJ4D,EAAI7C,YAAcoB,EAClByB,EAAI7F,UAAYA,EAEhB,IADA,IAAIiH,GAAa,EACRhB,EAAI,EAAGA,EAAIa,EAAOC,OAAQd,GAAK,EAAG,CACzC,IAAIlE,EAAI+E,EAAOb,GACX1D,EAAIuE,EAAOb,EAAI,GAEfiB,EAA2BvB,EAAc5D,GACzCoF,EAAY5E,GAAK2E,GAA4B3E,GAAK,EAClD4E,GAGFxB,EAAc5D,GAAKqB,KAAKgE,IAAI7E,EAAG2E,GAE3BD,EACFpB,EAAIvD,OAAOP,EAAGQ,GAEdsD,EAAIlD,OAAOZ,EAAGQ,IAIZ0E,EAEFpB,EAAIvD,OAAOP,EAAGQ,EAAI,EAAI,EAAI2E,GAE1BrB,EAAIlD,OAAOZ,EAAGQ,EAAI,EAAG,EAAI2E,GAG7BD,EAAaE,EAEftB,EAAIzD,UAMN,SAASuE,EAAaG,GACpB,KAAIA,EAAOC,OAAS,GAApB,CAEA,IAAIM,EAAcL,EAAeF,EAAQ7G,GAIzC,GAHA6G,EAASO,EAAYP,OAGjBO,EAAYC,IAAMD,EAAYD,IAAM,EAAG,CACzClD,EAAIjC,YACJiC,EAAIoC,UAAYhC,EAChBJ,EAAIvB,OAAOmE,EAAO,GAAIA,EAAO,IAC7B,IAAK,IAAIb,EAAI,EAAGA,EAAIa,EAAOC,OAAQd,GAAK,EACtC/B,EAAI5B,OAAOwE,EAAOb,GAAIa,EAAOb,EAAI,IAEnC/B,EAAI5B,OAAOwE,EAAOA,EAAOC,OAAS,GAAIM,EAAYC,KAClDpD,EAAI5B,OAAOwE,EAAO,GAAIO,EAAYC,KAClCpD,EAAIqD,YACJrD,EAAIsD,OAGNtD,EAAIjC,YACJiC,EAAIlB,YAAcoB,EAClBF,EAAIlE,UAAYA,EAChBkE,EAAIvB,OAAOmE,EAAO,GAAIA,EAAO,IAC7B,IAAK,IAAIb,EAAI,EAAGA,EAAIa,EAAOC,OAAQd,GAAK,EACtC/B,EAAI5B,OAAOwE,EAAOb,GAAIa,EAAOb,EAAI,IAEnC/B,EAAI9B,WAoBR,SAAS4E,EAAeF,EAAQW,GAK9B,IAJA,IAAIC,KACAJ,EAAMK,OAAOC,kBACbR,EAAMO,OAAOE,kBACbd,EAASD,EAAOC,OAAS,EACpBd,EAAI,EAAGA,EAAIc,EAAQd,GAAK,EAAG,CAOlC,IANA,IAAM6B,EAAa7B,EAAIwB,EAEjBM,EAAK9B,EAAIwB,EAAa,EAExBO,EAAQ,EACRC,EAAM,EACDC,EALIJ,GAAc,EAAIA,EAAa,EAKzBI,EAAIH,GAAMG,EAAInB,EAAQmB,GAAK,EAC5CD,GAAOnB,EAAO,EAAIoB,EAAI,GACtBF,GAAS,EAGX,IAAIG,EAAeF,EAAMD,EACzBN,EAAO,EAAIzB,GAAKa,EAAO,EAAIb,GAC3ByB,EAAO,EAAIzB,EAAI,GAAKkC,EAEhBb,EAAMa,IAAcb,EAAMa,GAC1Bf,EAAMe,IAAcf,EAAMe,GAGhC,OACErB,OAAQY,EACRN,MACAE,OAmBJ,SAASjD,EAAS+D,EAAOC,GACvB,OAAIA,EACF,IAAWC,EAAIF,EAAMlH,GAAKoH,EAAIF,EAAMjH,GAAKmH,EAAIF,EAAMhH,GAErD,QAAegH,EAAMlH,EAArB,KAA2BkH,EAAMjH,EAAjC,KAAuCiH,EAAMhH,EAA7C,KAAmDgH,EAAM/G,EAAzD,KAIJ,SAASiH,EAAIvG,GACX,GAAU,IAANA,EAAS,MAAO,KACpB,IAAIwG,EAAWxG,EAAEyG,SAAS,IAC1B,OAAOzG,EAAI,GAAK,IAAMwG,EAAWA,EC/S5B,IAAME,EAAe,4HCEtBC,yFAAgGD,EAClGE,EAAa,WAAItH,GAqCd,SAASuH,EAAmB9G,EAAK+G,EAAUC,GAC3CD,IAAUA,MAEf,IAEME,EAAsB,IACtBC,EAAWlH,EAAImH,UAAUD,SACzBE,EAAY9F,KAAK+F,IAAI,EAAGH,GAExBI,EAAgBtH,EAAImH,UAAUG,eAClCC,QAASL,EACTM,QAASN,EACTD,aAGIQ,EAA4BH,EA/BrBI,OAAO,SAACC,EAAQC,GAC3B,IAAIC,EAAID,EAAKE,UAMb,OALIH,EAAOI,KAAOF,EAAE5H,IAAG0H,EAAOI,KAAOF,EAAE5H,GACnC0H,EAAOK,KAAOH,EAAEpH,IAAGkH,EAAOK,KAAOH,EAAEpH,GACnCkH,EAAOM,KAAOJ,EAAE5H,IAAG0H,EAAOM,KAAOJ,EAAE5H,GACnC0H,EAAOO,KAAOL,EAAEpH,IAAGkH,EAAOO,KAAOL,EAAEpH,GAEhCkH,IAEPI,KAAMI,IACNH,KAAMG,IACNF,MAAM,IACNC,MAAM,MAqBFzG,EAAS2G,SAASC,cAAc,UAChCvJ,EAAQ2I,EAAWQ,KAAOR,EAAWM,KACrC9I,EAASwI,EAAWS,KAAOT,EAAWO,KAC5C,GAAIlJ,EAAQ,IAAMG,EAAS,GAAI,MAAM,IAAIqJ,MAAM,gDAE/C7G,EAAO3C,MAAQA,EAAQmI,EAAWA,EAClCxF,EAAOxC,OAASA,EAASgI,EAAWA,EACpC,IAAM7E,EAAMX,EAAOY,WAAW,MAExB0F,EAAON,EAAWM,KAClBC,EAAOP,EAAWO,KAExBjB,EAASwB,MAAQjB,EAAcrC,OAE/BuD,IAEA,IAAIC,SACAC,GAAc,EACZC,EAAcrB,EAActH,IA8GlC,SAAsB4H,GACpB,IAAMgB,EAkBR,SAA2BhB,GACzB,IAAMC,EAAID,EAAKE,UAMf,OACEe,IANUjC,EACTkC,QAAQ,OAAQjB,EAAEkB,GAClBD,QAAQ,OAAQjB,EAAEpH,GAClBqI,QAAQ,QAASjB,EAAE5H,GAIpBA,EAAGgH,GAAYY,EAAE5H,EAAIwH,EAAWM,MAChCtH,EAAGwG,GAAYY,EAAEpH,EAAIgH,EAAWO,OA5BlBgB,CAAkBpB,GAElC,OAvLsBiB,EAuLLD,EAAQC,IAtLvBI,EAAcpC,EAAWqC,IAAIL,GAC5BI,IACHA,EAAc,IAAIE,EAAA5J,EAAQ,SAAC6J,EAAS5K,GAClC,IAAM6K,EAAM,IAAIC,MAChBD,EAAIE,OAAS,WACXH,EAAQC,IAEVA,EAAIG,QAAUhL,EACd6K,EAAII,YAAc,YAClBJ,EAAIK,IAAMb,IAEZhC,EAAW8C,IAAId,EAAKI,IAGfA,GAyKFW,KAIH,SAAuBC,GACrBzH,EAAI0H,UAAUD,EAAOjB,EAAQ3I,EAAG2I,EAAQnI,KAJvCsJ,MAOH,WACE3H,EAAIjC,YACJiC,EAAIoC,UAAY,UAChBpC,EAAIqC,SAASmE,EAAQ3I,EAAG2I,EAAQnI,EAAGwG,EAAUA,KAT5C+C,QAAQxB,GA1LR,IAAmBK,EACpBI,IAgFJ,OATAE,EAAA5J,EAAQ0K,IAAItB,GACTiB,KA+BH,WACE,IAAMM,EAAczI,EAAO3C,MACrBqL,EAAO/H,EAAIgI,aAAa,EAAG,EAAGF,EAAazI,EAAOxC,QAAQkL,KAC1DE,EAActL,OAAOC,WACrBsL,EAAevL,OAAOG,YACxBqL,EAAa,IAAIzG,aAAauG,EAAcC,GAC5CE,SAEAC,EAAY,GACZ1H,EAAYoF,IACZnF,GAAamF,IACblF,GAAuB,EACvByH,EAAQ,EAGZ,OAFAjC,EAAgB1D,sBAIhB,SAAS4F,IAEP,IADA,IAAIC,EAAY7L,OAAO6F,YAAYD,MAC1BlE,EAAIiK,EAAOjK,EAAI6J,IAAgB7J,EAAG,CACzC,IAAK,IAAIR,EAAI,EAAGA,EAAIoK,IAAepK,EAAG,CACpC,IAAM4K,EAAQpK,EAAI4J,EAAcpK,EAC1BhB,EAAS6L,EAAU7K,EAAGQ,GAC5B8J,EAAWM,GAAS5L,EAChBA,EAAS8D,IAAWA,EAAY9D,GAChCA,EAAS+D,IACXA,EAAY/D,EACZgE,EAAsBxC,GAG1B,IAAIqE,EAAU/F,OAAO6F,YAAYD,MAAQiG,EACzC,GAAI9F,EAAU2F,EAEZ,YADK/B,IAAaD,EAAgB1D,sBAAsB4F,KAG1DD,EAAQjK,EAGV+J,GACEzH,YAAWC,YACXC,sBACAsH,aACAF,cACAC,mBA5BG,IAAInB,EAAA5J,EAAQ,SAAC6J,GAAcoB,EAAOpB,IAgCzC,SAAS0B,EAAU7K,EAAGQ,GACpB,IAAIsK,EAAS/K,EAAImH,UAAU6D,eAAe/K,IAAGQ,MAEzCwK,EAqEH,SAAkBC,EAAG9D,GAE1B,OADe8D,EAAI,KAAO,IAAO9D,EAtEjB+D,CAASJ,EAAOK,IAAKhE,GAC7BiE,GAAWJ,EAAQlD,GAAQd,EAC3BqE,EAwEH,SAAkBJ,EAAG9D,GAC1B,IAAIrJ,EAAQmN,EAAI5J,KAAKiK,GAAK,IAC1B,OACI,EAAIjK,KAAKkK,IAAKlK,KAAKmK,IAAI1N,GAAS,EAAIuD,KAAKoK,IAAI3N,IAC3CuD,KAAKiK,IACP,EAAKnE,EA7EOuE,CAASZ,EAAOa,IAAKxE,GAC7ByE,GAAWP,EAAQtD,GAAQf,EAC3B6E,EAAKxK,KAAKV,MAAMiL,GAChBE,EAAKzK,KAAKV,MAAMyK,GAEhBR,EAAkC,GAAzBiB,EAAK5B,EAAc6B,GAC5BC,EAAI7B,EAAKU,EAAQ,GACjBoB,EAAI9B,EAAKU,EAAQ,GACjBqB,EAAI/B,EAAKU,EAAQ,GAErB,OAGF,SAAsBmB,EAAGC,EAAGC,GAC1B,IAAIjN,EAAmD,IAA3B,IAAJ+M,EAAU,IAAU,IAAJC,EAAUC,GAApC,IACVjN,GAAU,MAGZA,GAAkB,KAEpB,OAAOA,EAVAkN,CAAaH,EAAGC,EAAGC,MA5F3BtC,KAcH,SAAmBwC,GACjB,IAAItN,EAAQsN,EAAe/B,YACvBF,EAAOiC,EAAe7B,WAE1B,OACEnG,iBAMF,SAA0BnE,EAAGQ,GAC3B,OAAO0J,EAAKlK,EAAIQ,EAAI3B,IANpBgE,iBAFK,WAGH,OAAOsJ,MApBVxC,KAAK,SAAA/J,GACC6I,GACH1B,EAAanH,MAKjB+B,OADK,WAEH8G,GAAc,EACd7G,qBAAqB4G,KAiIzB,SAASD,SACoB6D,IAAvBtF,EAASuF,YACXvF,EAASuF,WAAa,GAExBvF,EAASuF,UAAYhL,KAAKgE,IAAIyB,EAASwB,MAAOxB,EAASuF,UAAY,GACnEvF,EAAShF,QAAT,sBAAyCgF,EAASuF,UAAlD,OAAkEvF,EAASwB,MAA3E,OCtNJ,IAAIgE,EAAiBC,EAAQ,QAG7BA,uBACEA,EAAQ,SADVC,KAAA,KAAAC,IAAA3C,MAAA2C,EAAAC,IAKA,IAAI3M,OAAGA,EACH4M,SACAC,SAsCJ,SAASC,IACPhP,IAASW,WAAa,KACtB,IAAIgD,EAAS2G,SAAS2E,cAAc,eAChCtL,IAAQA,EAAOS,MAAMC,QAAU,KAcrC,SAAS6K,IACP,GAAKhN,EAAL,CAEA,IAAIiN,EAAkB7E,SAAS2E,cAAc,eACxCE,IAEDL,GACFA,EAAkBhL,SAEhBiL,GACFA,EAAcjL,SAGX9D,IAASc,YAIZqO,EAAgB/K,MAAMgL,QAAU,GAGlCpP,IAASe,gBACPkD,QAAS,GACT2G,aAAa,EACb4D,WAAW,GAIbO,EAAgB/F,EAAmB9G,EAAKlC,IAASe,eAEjD,SAA2B2C,GACzBoL,EAAoBrL,EAAwBzD,IAAU0D,EAAYyL,MAhBlEA,EAAgB/K,MAAMgL,QAAU,SAnEpCpP,IAASqP,KAKT,WACEC,IAASC,YAAc1G,EAEvB5H,OAAOiB,IAAMA,EAAM,IAAIoN,IAASE,KAC9BC,aAAa,EACbC,UAAW,MACXC,QAAS,EACTvL,MAAO,mCACPwL,SAAU,QAAS,QACnBC,KAAM,KACNC,MAAM,IAGR5N,EAAI6N,WACF,IAAIT,IAASU,mBAAoBC,aAAa,IAC9C,gBAEF/N,EAAI6N,WAAW,IAAItB,GAAiBc,YAAaD,IAASC,eAC1DrN,EAAIgO,GAAG,UAAW,WAChBhO,EAAIiO,KAAK,OAAQjB,KAEnBhN,EAAIgO,GAAG,YAAalB,GACpB9M,EAAIgO,GAAG,OAAQ,WACblQ,IAASC,MAAQiC,EAAIkO,eAIvBlO,EAAImO,WAAWC,UACfpO,EAAIqO,gBAAgBC,mBAhCtBxQ,IAASyQ,OAyCT,WACE,IAAK3B,EAAmB,OACxBA,EAAkBhL,SAClBgL,EAAkBjL,UA3CpB7D,IAASkP,UAAYA,EACrBlP,IAAS0Q,YA6CT,WACE,IAAK5B,EAAmB,OACxB,OAAOA,EAAkBjL,QAAO","file":"static/js/app.58a1baf3477d58ceb684.js","sourcesContent":["const appState = {\n  angle: 0,\n  currentState: 'intro',\n  lineDensity: 28,\n  lineWidth: 1,\n  smoothSteps: 1,\n  mapOpacity: 100,\n  heightScale: 42,\n  oceanLevel: 0,\n  aboutVisible: false,\n  error: null,\n  zazzleLink: null,\n  generatingPreview: false,\n  settingsOpen: false,\n  shouldDraw: false,\n  renderProgress: null,\n  width: window.innerWidth,\n  height: window.innerHeight,\n\n  backgroundColor: {\n    r: 0xF7, g: 0xF2, b: 0xE8, a: 1\n  },\n  lineBackground: {\n    // r: 255, g: 255, b: 255, a: 1\n    r: 0xF7, g: 0xF2, b: 0xE8, a: 1\n  },\n  lineColor: {\n    r: 22, g: 22, b: 22, a: 1.0\n  },\n};\n\nexport default appState;\n\n\n// WEBPACK FOOTER //\n// ./src/appState.js","/**\n * Basic proxy that acts like a 2d canvas context and renders paths\n * to SVG string. Supports limited subset of operations.\n */\nexport default function createSVGContext(width, height) {\n  let allPaths = [];\n  let currentPath;\n\n  let api = {\n    serialize,\n    beginPath,\n    lineTo,\n    moveTo,\n    stroke,\n    lineWidth: 1,\n    strokeStyle: '#161616'\n  }\n\n  return api;\n\n  function serialize() {\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: https://github.com/anvaka/peak-map  -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n   viewBox=\"0 0 ${width} ${height}\">\n<g id='paths'>\n   ${allPaths.reverse().map(x => x.serialize()).join('\\n')}\n</g>\n</svg>`\n  }\n\n  function beginPath() {\n    currentPath = createPath();\n  }\n\n  function lineTo(x, y) {\n    currentPath.lineTo(x, y);\n  }\n\n  function moveTo(x, y) {\n    currentPath.moveTo(x, y);\n  }\n\n  function stroke() {\n    if (currentPath && !currentPath.isEmpty()) {\n      if (api.strokeStyle) {\n        currentPath.setStroke(api.strokeStyle);\n      }\n      if (api.lineWidth) {\n        currentPath.setLineWidth(api.lineWidth);\n      }\n      allPaths.push(currentPath);\n    }\n  }\n}\n\nfunction createPath() {\n  let segments = [];\n  let lastCommand = null;\n  let stroke, lineWidth;\n  let lineCount = 0;\n\n  return {\n    lineTo,\n    moveTo,\n    serialize,\n    isEmpty() {\n      return lineCount === 0;\n    },\n    setStroke(strokeStyle) {\n      stroke = strokeStyle;\n    },\n    setLineWidth(customLineWidth) {\n      lineWidth = customLineWidth;\n    },\n  }\n\n  function serialize() {\n    let strokeString = stroke ? `stroke=\"${stroke}\" ` : '';\n    let lineWidthString = lineWidth !== 1 ? `stroke-width=\"${lineWidth}\"` : '';\n    return `<path d=\"${segments.join(' ')}\" fill=\"none\" ${strokeString}${lineWidthString}></path>`\n  }\n\n  function moveTo(x, y) {\n    let prefix = lastCommand === 'M' ? '' : 'M';\n    segments.push(`${prefix}${round(x)} ${round(y)}`)\n    lastCommand = 'M';\n  }\n\n  function lineTo(x, y) {\n    lineCount += 1;\n    let prefix = lastCommand === 'L' ? '' : 'L';\n    segments.push(`${prefix}${round(x)} ${round(y)}`)\n    lastCommand = 'L';\n  }\n}\n\nfunction round(x) {\n  return Math.round(x * 100)/100\n}\n\n\n// WEBPACK FOOTER //\n// ./src/lib/createSVGContext.js","import createSVGContext from './createSVGContext';\n\n/**\n * This is the core component of the website which renders lines on the overlay\n * layer\n * @param {*} appState - @see ../appState.js\n * @param {*} map  - mapbox map instance\n * @param {*} canvas  - where the lines should be rendered\n */\nexport default function createHeightMapRenderer(appState, regionInfo, canvas) {\n  let renderHandle;\n\n  render();\n\n  return {\n    /**\n     * When new render request is created, we have to cancel the current one:\n     */\n    cancel,\n    render\n  }\n\n  function render(toSVG) {\n    // let's set everything up to match our application state:\n    if (appState.renderProgress) {\n      appState.renderProgress.message = 'Rendering...'\n    }\n\n    const oceanLevel = Number.parseFloat(appState.oceanLevel);\n\n    let smoothSteps = parseFloat(appState.smoothSteps);\n\n    canvas.style.opacity = appState.mapOpacity/100;\n\n    let ctx = canvas.getContext('2d');\n    let lineStroke = getColor(appState.lineColor);\n    let lineFill = getColor(appState.lineBackground);\n    let lineWidth = Number.parseFloat(appState.lineWidth);\n\n    let resHeight = window.innerHeight;\n    let resWidth = window.innerWidth;\n    let rowCount = Math.round(resHeight * appState.lineDensity/100); \n    let scale = appState.heightScale;\n\n    // since tiles can be partially overlapped, we use our own iterator\n    // over partially overlapped tiles (to not deal with offset math here)\n    const {minHeight, maxHeight, rowWithHighestPoint} = regionInfo.getAllHeightData();\n    const iteratorSettings = createRegionIterator(rowCount, resHeight, rowWithHighestPoint);\n\n    // we want the scale be independent from the zoom level, use the distribution\n    // of heights as our scaler:\n    let heightRange = maxHeight - minHeight;\n\n    let lastLine = [];\n    let lastRow = iteratorSettings.start;\n\n    // When rendered to SVG - count the filled area, so that we can break paths\n    // if they overlap already rendered paths\n    let columnHeights;\n\n    if (toSVG) {\n      // SVG needs hex values, not rgba, also ignore alpha\n      lineStroke = getColor(appState.lineColor, /* useHex = */ true);\n      columnHeights = new Float32Array(window.innerWidth);\n      lastRow = iteratorSettings.stop;\n      // This is going to be our look up structure. Point `(x, y)` is visible\n      // only if its `y` coordinate is smaller than `columnHeight[x]` value.\n      // (we render from bottom to top for svg files)\n      for (let x = 0; x < window.innerWidth; ++x) {\n        columnHeights[x] = window.innerHeight;\n      }\n      return renderSVGRows();\n    } else {\n      clearScene();\n      return renderRows();\n    }\n\n    // Public part is over. Below is is just implementation detail\n\n    function renderSVGRows() {\n      let svg = createSVGContext(window.innerWidth, window.innerHeight); // || ctx - they both work here.\n      let row = 0;\n      let width = window.innerWidth;\n      for (let y = lastRow; y > 0; y -= iteratorSettings.step) {\n        drawSVGLine(lastLine, svg);\n        lastLine = [];\n        let isEven = (row % 2) === 0\n        row += 1;\n\n        for (let i = 0; i < width; i += 1) {\n          let x = isEven ? i : width - 1 - i;\n          let height = regionInfo.getHeightAtPoint(x, y);\n          let fY = y - Math.floor(scale * (height - minHeight) / heightRange);\n          if (height <= oceanLevel) {\n            drawSVGLine(lastLine, svg);\n            lastLine = [];\n          } else {\n            lastLine.push(x, fY);\n          }\n        }\n\n        lastRow = y - iteratorSettings.step;\n      }\n\n      drawSVGLine(lastLine, svg);\n\n      appState.renderProgress = null;\n      if (svg.serialize) {\n        // ctx (used for debugging) doesn't have this method\n        return svg.serialize();\n      }\n    }\n\n    /**\n     * This renders rows, and stops if allowed time quota is exceeded (making rendering\n     * async, so that we do not freeze the main thread)\n     */\n    function renderRows() {\n      let now = performance.now();\n\n      for (let y = lastRow; y <= iteratorSettings.stop; y += iteratorSettings.step) {\n        drawPolyLine(lastLine, true);\n        lastLine = [];\n\n        for (let x = 0; x < window.innerWidth; ++x) {\n          let height = regionInfo.getHeightAtPoint(x, y);\n          let fY = y - Math.floor(scale * (height - minHeight) / heightRange);\n\n          if (height <= oceanLevel) {\n            drawPolyLine(lastLine, true);\n            lastLine = [];\n          } else {\n            lastLine.push(x, fY);\n          }\n        }\n\n        lastRow = y + iteratorSettings.step;\n        let elapsed = performance.now() - now;\n        if (elapsed > 200) {\n          renderHandle = requestAnimationFrame(renderRows);\n          return;\n        }\n      }\n\n      drawPolyLine(lastLine, true);\n\n      appState.renderProgress = null;\n    }\n\n    /**\n     * Draws a polyline, that does not intersect already rendered\n     * lines. Assumption is that we render from bottom to the top.\n     * \n     * \n     */\n    function drawSVGLine(points, svg) {\n      if (points.length < 3) return;\n\n      let smoothRange = getSmoothRange(points, smoothSteps);\n      points = smoothRange.points;\n\n      svg.beginPath();\n      svg.strokeStyle = lineStroke;\n      svg.lineWidth = lineWidth;\n      let wasVisible = false;\n      for (let i = 0; i < points.length; i += 2) {\n        let x = points[i];\n        let y = points[i + 1];\n\n        let lastRenderedColumnHeight = columnHeights[x];\n        let isVisible = y <= lastRenderedColumnHeight && y >= 0;\n        if (isVisible) {\n          // This is important bit. We mark the entire area below as \"rendered\"\n          // so that next `isVisible` check will return false, and we will break the line\n          columnHeights[x] = Math.min(y, lastRenderedColumnHeight)\n          // the path is visible:\n          if (wasVisible) {\n            svg.lineTo(x, y);\n          } else {\n            svg.moveTo(x, y);\n          }\n        } else {\n          // The path is no longer visible\n          if (wasVisible) {\n            // But it was visible before\n            svg.lineTo(x, y < 0 ? 0 : lastRenderedColumnHeight);\n          } else {\n            svg.moveTo(x, y < 0? 0 : lastRenderedColumnHeight);\n          }\n        }\n        wasVisible = isVisible;\n      }\n      svg.stroke();\n    }\n\n    /**\n     * Draws filled polyline.\n     */\n    function drawPolyLine(points) {\n      if (points.length < 3) return;\n\n      let smoothRange = getSmoothRange(points, smoothSteps);\n      points = smoothRange.points;\n\n      // If line's height is greater than 2 pixels, let's fill it:\n      if (smoothRange.max - smoothRange.min > 2) {\n        ctx.beginPath();\n        ctx.fillStyle = lineFill;\n        ctx.moveTo(points[0], points[1]);\n        for (let i = 2; i < points.length; i += 2) {\n          ctx.lineTo(points[i], points[i + 1]);\n        }\n        ctx.lineTo(points[points.length - 2], smoothRange.max);\n        ctx.lineTo(points[0], smoothRange.max);\n        ctx.closePath();\n        ctx.fill();\n      }\n\n      ctx.beginPath();\n      ctx.strokeStyle = lineStroke;\n      ctx.lineWidth = lineWidth;\n      ctx.moveTo(points[0], points[1]);\n      for (let i = 2; i < points.length; i += 2) {\n        ctx.lineTo(points[i], points[i + 1]);\n      }\n      ctx.stroke();\n    }\n\n    function clearScene() {\n      ctx.beginPath();\n      ctx.clearRect(0, 0, resWidth, resHeight);\n      ctx.fillStyle = getColor(appState.backgroundColor);\n      ctx.fillRect(0, 0, resWidth, resHeight);\n    }\n  }\n\n  function cancel() {\n    cancelAnimationFrame(renderHandle)\n    appState.renderProgress = null;\n  }\n\n  /**\n   * Simple smoothing function with moving averages, augmented with\n   * min/max calculation (don't want to spend more CPU cycles fo min/max)\n   */\n  function getSmoothRange(points, windowSize) {\n    let result = [];\n    let max = Number.NEGATIVE_INFINITY;\n    let min = Number.POSITIVE_INFINITY;\n    let length = points.length / 2;\n    for (let i = 0; i < length; i += 1) {\n      const leftOffset = i - windowSize;\n      const from = leftOffset >= 0 ? leftOffset : 0\n      const to = i + windowSize + 1;\n\n      let count = 0\n      let sum = 0\n      for (let j = from; j < to && j < length; j += 1) {\n        sum += points[2 * j + 1]\n        count += 1\n      }\n\n      let smoothHeight = sum / count;\n      result[2 * i] = points[2 * i];\n      result[2 * i + 1] = smoothHeight;\n\n      if (max < smoothHeight) max = smoothHeight;\n      if (min > smoothHeight) min = smoothHeight;\n    }\n\n    return {\n      points: result,\n      min,\n      max\n    };\n  }\n\n  /**\n   * Iterate over height map.\n   */\n  function createRegionIterator(rowCount, resHeight, includeRowIndex) {\n    let stepSize = Math.round(resHeight / rowCount);\n    let start = includeRowIndex - Math.floor(includeRowIndex/stepSize) * stepSize;\n    let stop = start + stepSize * Math.floor((resHeight - start) / stepSize)\n\n    return {\n      start,\n      stop,\n      step: stepSize,\n    }\n  }\n\n  function getColor(color, useHex) {\n    if (useHex) {\n      return `#${hex(color.r)}${hex(color.g)}${hex(color.b)}`;\n    }\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`\n  }\n}\n\nfunction hex(x) {\n  if (x === 0) return '00';\n  let hexValue = x.toString(16)\n  return x < 16 ? '0' + hexValue : hexValue;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/lib/createHeightMapRenderer.js","export const MAPBOX_TOKEN = 'pk.eyJ1IjoiYW52YWthIiwiYSI6ImNrNWRqcDdnNTF4MHYzbXAzNDJzODludnYifQ.2WDAbuAzUuchNtCAcZitAw';\n\n\n\n// WEBPACK FOOTER //\n// ./src/config.js","import { MAPBOX_TOKEN } from \"./config\";\n\nconst apiURL = `https://api.mapbox.com/v4/mapbox.terrain-rgb/zoom/tLong/tLat@2x.pngraw?access_token=${MAPBOX_TOKEN}`;\nlet imageCache = new Map();\n\nexport function loadImage(url) {\n  let cachedImage = imageCache.get(url);\n  if (!cachedImage) {\n    cachedImage = new Promise((resolve, error) => {\n      const img = new Image();\n      img.onload = () => {\n        resolve(img);\n      };\n      img.onerror = error;\n      img.crossOrigin = \"anonymous\";\n      img.src = url;\n    });\n    imageCache.set(url, cachedImage);\n  }\n\n  return cachedImage;\n}\n\nfunction getTilesBounds(tiles) {\n  return tiles.reduce((bounds, tile) => {\n    let p = tile.canonical;\n    if (bounds.minX > p.x) bounds.minX = p.x;\n    if (bounds.minY > p.y) bounds.minY = p.y;\n    if (bounds.maxX < p.x) bounds.maxX = p.x;\n    if (bounds.maxY < p.y) bounds.maxY = p.y;\n\n    return bounds;\n  }, {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  })\n}\n\nexport function getRegionElevation(map, progress, doneCallback) {\n  if (!progress) progress = {};\n\n  const renderHD = true;\n\n  const tileSize = renderHD ? 512 : 256;\n  const tileZoom = map.transform.tileZoom;\n  const zoomPower = Math.pow(2, tileZoom);\n\n  const coveringTiles = map.transform.coveringTiles({\n    minzoom: tileZoom,\n    maxzoom: tileZoom,\n    tileSize\n  });\n\n  const tileBounds = getTilesBounds(coveringTiles);\n\n  const canvas = document.createElement(\"canvas\");\n  const width = tileBounds.maxX - tileBounds.minX;\n  const height = tileBounds.maxY - tileBounds.minY;\n  if (width > 50 || height > 50) throw new Error('Too many tiles requested. How did you do it?');\n\n  canvas.width = width * tileSize + tileSize;\n  canvas.height = height * tileSize + tileSize;\n  const ctx = canvas.getContext('2d');\n\n  const minX = tileBounds.minX;\n  const minY = tileBounds.minY;\n\n  progress.total = coveringTiles.length;\n\n  advanceProgress();\n\n  let heightsHandle;\n  let isCancelled = false;\n  const tilesToLoad = coveringTiles.map(toLoadedTile);\n\n  Promise.all(tilesToLoad)\n    .then(computeVisibleHeights)\n    .then(createAPI)\n    .then(api => {\n      if (!isCancelled) {\n        doneCallback(api)\n      }\n    });\n\n  return {\n    cancel() {\n      isCancelled = true;\n      cancelAnimationFrame(heightsHandle);\n    }\n  }\n\n  function createAPI(visibleHeights) {\n    let width = visibleHeights.windowWidth;\n    let data = visibleHeights.allHeights;\n\n    return {\n      getHeightAtPoint,\n      getAllHeightData() {\n        return visibleHeights;\n      }\n    };\n\n    function getHeightAtPoint(x, y) {\n      return data[x + y * width];\n    }\n  }\n\n  function computeVisibleHeights() {\n    const canvasWidth = canvas.width;\n    const data = ctx.getImageData(0, 0, canvasWidth, canvas.height).data;\n    const windowWidth = window.innerWidth;\n    const windowHeight = window.innerHeight;\n    let allHeights = new Float32Array(windowWidth * windowHeight);\n    let done;\n\n    let timeQuota = 16;\n    let minHeight = Infinity;\n    let maxHeight = -Infinity;\n    let rowWithHighestPoint = -1;\n    let lastY = 0;\n    heightsHandle = requestAnimationFrame(collectHeights); // todo let it be cancelled;\n\n    return new Promise((resolve) => { done = resolve });\n\n    function collectHeights() {\n      let startTime = window.performance.now();\n      for (let y = lastY; y < windowHeight; ++y) {\n        for (let x = 0; x < windowWidth; ++x) {\n          const index = y * windowWidth + x;\n          const height = getHeight(x, y);\n          allHeights[index] = height;\n          if (height < minHeight) minHeight = height;\n          if (height > maxHeight) {\n            maxHeight = height;\n            rowWithHighestPoint = y;\n          }\n        }\n        let elapsed = window.performance.now() - startTime;\n        if (elapsed > timeQuota) {\n          if (!isCancelled) heightsHandle = requestAnimationFrame(collectHeights);\n          return;\n        }\n        lastY = y;\n      }\n\n      done({\n        minHeight, maxHeight, \n        rowWithHighestPoint, \n        allHeights,\n        windowWidth,\n        windowHeight\n      });\n    }\n\n    function getHeight(x, y) {\n      let lngLat = map.transform.pointLocation({x, y})\n\n      let xTile = lng2tile(lngLat.lng, zoomPower);\n      let xOffset = (xTile - minX) * tileSize;\n      let yTile = lat2tile(lngLat.lat, zoomPower);\n      let yOffset = (yTile - minY) * tileSize;\n      let yC = Math.round(yOffset);\n      let xC = Math.round(xOffset);\n\n      let index = (yC * canvasWidth + xC) * 4;\n      let R = data[index + 0];\n      let G = data[index + 1];\n      let B = data[index + 2];\n\n      return decodeHeight(R, G, B)\n    }\n\n    function decodeHeight(R, G, B) {\n      let height = -10000 + ((R * 256 * 256 + G * 256 + B) * 0.1)\n      if (height < -100) {\n        // Fiji islands data has huge caves, which pushes the entire thing up.\n        // I'm reducing it.\n        height = height / 5000;\n      }\n      return height;\n    }\n  }\n\n  function toLoadedTile(tile) {\n    const request = getRequestForTile(tile);\n\n    return loadImage(request.url)\n      .then(drawTileImage)\n      .catch(drawBlankTile)\n      .finally(advanceProgress);\n\n    function drawTileImage(image) {\n      ctx.drawImage(image, request.x, request.y);\n    }\n\n    function drawBlankTile() {\n      ctx.beginPath();\n      ctx.fillStyle = '#0186a0'; // zero height\n      ctx.fillRect(request.x, request.y, tileSize, tileSize);\n    }\n  }\n\n  function getRequestForTile(tile) {\n    const p = tile.canonical;\n    const url = apiURL\n      .replace('zoom', p.z)\n      .replace('tLat', p.y)\n      .replace('tLong', p.x);\n\n    return {\n      url,\n      x: tileSize * (p.x - tileBounds.minX), \n      y: tileSize * (p.y - tileBounds.minY)\n    }\n  }\n\n  function advanceProgress() {\n    if (progress.completed === undefined) {\n      progress.completed = -1;\n    }\n    progress.completed = Math.min(progress.total, progress.completed + 1);\n    progress.message = `Downloading tiles: ${progress.completed} of ${progress.total}...`\n  }\n  \n}\n\nexport function lng2tile(l, zoomPower) {\n  let result = ((l + 180) / 360) * zoomPower;\n  return result;\n}\n\nexport function lat2tile(l, zoomPower) {\n  let angle = l * Math.PI / 180;\n  return (\n    ((1 - Math.log( Math.tan(angle) + 1 / Math.cos(angle)) /\n        Math.PI) /\n      2) * zoomPower \n  );\n}\n\nexport function tile2long(x, zoomPower) {\n  return (x / zoomPower) * 360 - 180;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/elevation.js","/**\n * This is the website startup point.\n */\nimport appState from \"./appState\";\nimport mapboxgl from \"mapbox-gl\";\nimport createHeightMapRenderer from \"./lib/createHeightMapRenderer\";\nimport { MAPBOX_TOKEN } from \"./config\";\nimport { getRegionElevation } from './elevation';\n\nvar MapboxGeocoder = require(\"@mapbox/mapbox-gl-geocoder\");\n\n// Load vue asyncronously\nrequire.ensure(\"@/vueApp.js\", () => {\n  require(\"@/vueApp.js\");\n});\n\n// Hold a reference to mapboxgl instance.\nlet map;\nlet heightMapRenderer;\nlet regionBuilder;\n// Let the vue know what to call to start the app.\nappState.init = init;\nappState.redraw = redraw;\nappState.updateMap = updateMap;\nappState.exportToSVG = exportToSVG;\n\nfunction init() {\n  mapboxgl.accessToken = MAPBOX_TOKEN;\n\n  window.map = map = new mapboxgl.Map({\n    trackResize: true,\n    container: \"map\",\n    minZoom: 0,\n    style: \"mapbox://styles/mapbox/light-v10\",\n    center: [-122.574, 47.727],\n    zoom: 7.68,\n    hash: true\n  });\n\n  map.addControl(\n    new mapboxgl.NavigationControl({ showCompass: false }),\n    \"bottom-right\"\n  );\n  map.addControl(new MapboxGeocoder({ accessToken: mapboxgl.accessToken }));\n  map.on('moveend', function() {\n    map.once('idle', updateMap)\n  });\n  map.on(\"movestart\", hideHeights);\n  map.on(\"load\", function() {\n    appState.angle = map.getBearing();\n    // map.showTileBoundaries = true;\n  });\n\n  map.dragRotate.disable();\n  map.touchZoomRotate.disableRotation();\n}\n\nfunction hideHeights() {\n  appState.zazzleLink = null;\n  let canvas = document.querySelector(\".height-map\");\n  if (canvas) canvas.style.opacity = 0.02;\n}\n\nfunction redraw() {\n  if (!heightMapRenderer) return;\n  heightMapRenderer.cancel();\n  heightMapRenderer.render();\n}\n\nfunction exportToSVG() {\n  if (!heightMapRenderer) return;\n  return heightMapRenderer.render(true);\n}\n\nfunction updateMap() {\n  if (!map) return;\n\n  let heightMapCanvas = document.querySelector(\".height-map\");\n  if (!heightMapCanvas) return;\n\n  if (heightMapRenderer) {\n    heightMapRenderer.cancel();\n  }\n  if (regionBuilder) {\n    regionBuilder.cancel();\n  }\n\n  if (!appState.shouldDraw) {\n    heightMapCanvas.style.display = \"none\";\n    return;\n  } else {\n    heightMapCanvas.style.display = \"\";\n  }\n  \n  appState.renderProgress = {\n    message: '',\n    isCancelled: false,\n    completed: false\n  };\n\n  // This will fetch all heightmap tiles\n  regionBuilder = getRegionElevation(map, appState.renderProgress, showRegionHeights)\n\n  function showRegionHeights(regionInfo) {\n    heightMapRenderer = createHeightMapRenderer(appState, regionInfo, heightMapCanvas);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js"],"sourceRoot":""}